# Лабораторная работа 7: Внедрение зависимостей (Dependency Injection)

## Описание

Данная лабораторная работа демонстрирует реализацию паттерна "Внедрение зависимостей" на языке C++. Создан сервис, который управляет ассоциациями между интерфейсами и классами их реализующими.

## Основные компоненты

### 1. Класс Injector
Основной класс для управления зависимостями, поддерживает:
- **3 режима жизненного цикла** (LifeStyle):
  - `PER_REQUEST` - каждый раз создается новый экземпляр
  - `SCOPED` - один экземпляр в рамках области видимости
  - `SINGLETON` - всегда один и тот же экземпляр

- **Регистрация зависимостей**:
  - `register_type<Interface, Class>(lifestyle, params)` - регистрация типа
  - `register_factory<Interface>(factory, lifestyle)` - регистрация фабричного метода

- **Получение экземпляров**:
  - `get_instance<Interface>()` - получение экземпляра по интерфейсу

### 2. Интерфейсы и реализации
Созданы три интерфейса с двумя реализациями каждый:

- **Interface1**: `Class1Debug`, `Class1Release`
- **Interface2**: `Class2Debug`, `Class2Release` 
- **Interface3**: `Class3Debug`, `Class3Release`

### 3. Конфигурации
- `config_debug()` - конфигурация для отладочного режима
- `config_release()` - конфигурация для релизного режима
- `config_complex()` - демонстрация сложных зависимостей

## Сборка и запуск

### С помощью CMake:
```bash
mkdir build
cd build
cmake ..
make
./dependency_injection
```

### Прямая компиляция:
```bash
g++ -std=c++17 -o dependency_injection main.cpp
./dependency_injection
```

## Демонстрация возможностей

Программа демонстрирует:

1. **Различные жизненные циклы**:
   - PerRequest создает новые экземпляры каждый раз
   - Scoped создает один экземпляр в рамках области видимости
   - Singleton всегда возвращает один и тот же экземпляр

2. **Различные конфигурации**:
   - Debug режим с отладочными реализациями
   - Release режим с оптимизированными реализациями

3. **Сложные зависимости**:
   - Автоматическое разрешение зависимостей между классами
   - Передача параметров в конструкторы

## Особенности реализации

- Использование `std::shared_ptr` для автоматического управления памятью
- Потокобезопасность с помощью `std::mutex`
- Обнаружение циклических зависимостей
- Поддержка фабричных методов для создания объектов
- Простой и понятный API для студентов

## Требования

- C++17 или выше
- CMake 3.10+ (опционально)

